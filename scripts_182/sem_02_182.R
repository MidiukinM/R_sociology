
# Задача 6 (семинар 1)
a <- 10
b <- 20

print('До')
print(a)
print(b)

c <- a
a <- b
b <- c

print('После замены местами:')
print(a)
print(b)

# Задание 11 (семинар 1)

x1 <- sample(1:10, size=4, replace=TRUE)
x2 <- sample(1:10, size=4, replace=TRUE)

# операция сложения векторизованна - операция применяется к каждому элементу массива
x1 + x2

x1[3] <- NA
x1

x3 <- x1 + x2

sum(x3, na.rm=TRUE)
mean(x3, na.rm=TRUE)

x1 
x2 

x1_mod <- c(100, x1)

x1_mod
x2

x1_mod + x2

# склеиваем массивы
c(x1, x2) 

# IF

a <- 10
b <- 10
c <- 0

# читерский вариант
max(c(a, b, c))

# норм вариант
# if не идет дальше, как только увидел первое совпадение
if (a>=b & a>=c){ 
  print('a')
  print(a)
} else if (b>=a & b>=c){
  print('b')
  print(b)
} else {
  print('c')
  print(c)
}

# Вам дан год. Надо проверить, високосный ли он? 
# Год является високосным если он делится на 4, но не делится на 100 либо если он делится на 400

year <- 2004

if (year %% 100 > 0 & year %% 4 == 0){
  print('Високосный')
} else if (year %% 400 == 0){
  print('Високосный')
} else {
  print('Нет')
}


# Задача 5 (Семинар 2)

a <- 9

if (a %% 2 == 0){
  print('Четное')
} else {
  print('Нечетное')
}

# Задачи на массивы

## Способы создания массива и немного тервера
c(1, 2, 3)

seq(1, 10, 2)

1:10

rep(4, 10)

sample(seq(1, 10, 2), size=4, replace=TRUE)
sample(1:10, size=15, replace=TRUE)

sample(c('Орел', 'Решка'), size=1)

coin_vec <- sample(c(0, 1), size=10000, replace=TRUE)

mean(coin_vec) # оцененная вер-ть выпадения решки 
1 - mean(coin_vec) # оцененная вер-ть выпадения орла


coin_vec <- sample(c(0, 1), size=10000, replace=TRUE, prob=c(0.3, 0.7))

mean(coin_vec) # оцененная вер-ть выпадения решки 
1 - mean(coin_vec) # оцененная вер-ть выпадения орла

## Вывести 1ый и последний эл-т массива

x <- sample(1:10, size=5, replace=TRUE)
x

indx <- c(1, length(x))
x[indx]

x[c(1, length(x))]

# ЧТО МЫ МОЖЕМ ПЕРЕДАВАТЬ ВНУТРЬ КВАДРАТНЫХ СКОБОК:
# 1) число   2) несколько чисел (только с помощью массива)    3) TRUE/FALSE, условия

## Есть массив из чисел. Вывести только положительные четные числа. 

x <- sample(-10:10, size=10, replace=FALSE)
x

# булевский массив - массив из TRUE/FALSE
x > 0 & x %% 2 == 0

# делает нам срез по булевскому массиву и оставляет только те числа в массиве х, которые стоят на месте TRUE
x[x > 0 & x %% 2 == 0]

usl1 <- x > 0
usl2 <- x %% 2 == 0

x[usl1 & usl2]




















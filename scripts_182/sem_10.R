

# мы создали переменную, куда будем класть сумму на каждом шаге
# а затем пробегаемся по всему массиву и поэлементно складываем все значения
s <- 0
for (i in 1:length(x)){
  s <- s + x[i]
}

## Порядок защиты
# 1. Если работы похожи, ставится 0
# 2. Студент может не согласиться со своей оценкой за дз (не только с 0, с любой оценкой)
# 3. Задаю 2 вопроса: 
## 3.1 Вы отвечаете на оба вопроса => оценка повышается 
## 3.2 Вы отвечаете на один вопрос => задается 3ий вопрос => если ответил, то оценка повышается
## 3.3 Ни на один вопрос из двух не ответили => оценка остается такой же либо может понизиться

## Изучаем ЗБЧ: 

Исходы (что мы можем получить, подбрасывая кубик): X:     1    2    3    4    5     6
Вероятности этих исходов:                          P(X): 1/6  1/6  1/6  1/6  1/6   1/6 => 1

X - число, которое выпало при подбрасывании кубика (случайная величина)
E(X) = 1/6 * 1 + 1/6 * 2 + ... + 6 * 1/6 = (1 + 2 + ... + 6) / 6 = 3.5

n - число кубиков => есть X_n случайных величин 

X_1:     1    2    3    4    5     6
P(X_1): 1/6  1/6  1/6  1/6  1/6   1/6 => 1

X_2:     1    2    3    4    5     6
P(X_2): 1/6  1/6  1/6  1/6  1/6   1/6 => 1
 
... 

Если у вас: 
  1. Большая выборка (много случайных величин, которые одинаково распределены):
        Вы имеете много одинаковых кубиков, которые вы подбрасываете по одному разу
  2. Случайные величины независимы 
        То, что у вас на 1ом кубике выпало 2 никак не влияет на то, что на 2ом кубике выпадет тоже 2/3/4

=> Среднее значение всех исходов сходится (по вер-ти) к E(X) = 3.5

X - прибыль компании

X:    100-11000=-10900         100
P(X):    0.01             1-0.01 = 0.99

E(X) = -10900 * 0.01 + 100 * 0.99 = -10 рублей
  
  
  
## Парадокс дней рождений
Если дни рождения людей распределены равномерно, 
(то есть у конкретного человека вер-ть родиться в любой день она примерно одинакова)
То тогда вероятность совпадения даты дней рождений (месяц и день) у 50 людей равна 0.97


data <- read.csv('/Users/maksimmidukin/Documents/R_repo/R_sociology/day_07/data/birthdays.csv', sep=',')

head(data)

# city,first_name,id,sex,byear,bmonth,bday,bdate;Севастополь,Галина,...
dim(data)

str(data)

# 1. Я хочу проверить, что данные распределены равномерно (по месяцам)

n_people <- c()
for (month in 1:12){
  data_small <- data[data$bmonth == month, ]
  n <- dim(data_small)[1]
  n_people <- append(n_people, n)
}

barplot(n_people)

data_small <- data[data$bmonth == 1, ]
data_small
dim(data_small)[1]

data_small <- data[data$bmonth == 2, ]
data_small
dim(data_small)[1]

data_small <- data[data$bmonth == 3, ]
data_small
dim(data_small)[1]

data_small <- data[data$bmonth == 12, ]
data_small
dim(data_small)[1]

x <- c(1, 2, 3, 4)

x[x > 2]

m <- matrix(1:15, nrow=5, ncol=3)
m

m[m[,1] > 2, ]

# рисуем тоже самое но проще (с помощью пакета ggplot2 - будем подробно изучать на след семинарах)
library(ggplot2)

data$bmonth <- factor(data$bmonth)
ggplot(data, aes(x = bmonth)) + geom_histogram(stat="count")

## Вывод: Похоже на равномерность


n <- 1000

# счетчик для наших событий (здесь будем считать сколько раз др совпало хотя бы у 2х людей)
m <- 0
# делаем это n раз
for (i in 1:n){
  # здесь мы отбираем 50 случайных людей
  people_rows <- sample(1:nrow(data), size=50, replace=FALSE)
  # смотрим, есть ли совпадения
  otvet <- length(unique(data[people_rows, 'bdate'])) < 50 
  # TRUE: 1, FALSE: 0
  m <- m + otvet
}

print(m / n) # оценили вероятность

data[people_rows, ]

data[c(1, 2), ]



sample(c(1, 0), size=1)

